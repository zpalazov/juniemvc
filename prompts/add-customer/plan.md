1. Define the Customer database entity. 
   - Create the Customer JPA entity with fields: id PK, name (required), email, phone (numeric or string per DB constraints), addressLine1 (required), addressLine2, city (required), state (required), postalCode (required). Add validation annotations where appropriate (e.g., @NotBlank, @Email, @Pattern for postal code, etc.).
   - Establish one-to-many relationship from Customer to BeerOrder (List<BeerOrder> orders). If BeerOrder exists, add a many-to-one back-reference to Customer and map cascade and fetch strategies as needed. Ensure non-owning vs owning side is consistent (BeerOrder owns the FK to customer).

2. Plan database schema and Flyway migration.
   - Create Flyway SQL migration under src/main/resources/db/migration with proper version naming (e.g., V3__add_customers_and_relation.sql depending on current latest version).
   - Migration should: create customers table with columns for all fields and auditing timestamps; add customer_id FK column to beer_orders (or equivalent) if not present; create indexes on customer_id and frequently queried fields (email, phone optionally unique if business rules require).
   - Use appropriate SQL types: INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY for id (matching project convention), VARCHAR for strings, numeric type for phone if numeric, timestamps with timezone for created/updated.
   - Add constraints: NOT NULL for required fields; optional UNIQUE on email if desired (confirm business rule before enforcing).

3. Introduce DTOs for API/service layers.
   - Create request/command DTOs: CreateCustomerRequest, UpdateCustomerRequest with Jakarta validation annotations; avoid exposing internal IDs in create requests.
   - Create response DTO: CustomerResponse with all public fields including id and timestamps.
   - Consider a lightweight summary DTO for list views (CustomerSummaryResponse) if needed for pagination.

4. Mapping with MapStruct.
   - Add MapStruct dependency (annotationProcessor and kapt/ksp if Kotlin) in build.gradle.kts if not already present; align versions with Kotlin and Spring Boot.
   - Create a CustomerMapper interface: entityToResponse, entitiesToResponses, createRequestToEntity, updateRequestOntoEntity (@MappingTarget), and entityToSummary if used.
   - Configure null handling and date/time mapping; ensure phone/string conversions if necessary.

5. Repository layer.
   - Create CustomerRepository extending JpaRepository<Customer, UUID>. Add finder methods as needed (e.g., findByEmail) but keep minimal initially.

6. Service layer with clear transaction boundaries.
   - Create CustomerService with methods: create(CreateCustomerRequest), getById(UUID), list(Pageable), update(UUID, UpdateCustomerRequest), delete(UUID).
   - Use @Transactional on write methods, @Transactional(readOnly = true) on reads. Throw NotFoundException when customer is missing.
   - Implement business rules (e.g., prevent duplicate emails if unique) and rely on repository and mapper. Return DTOs from service.

7. Web layer (REST Controller).
   - Create CustomerController under /api/v1/customers with endpoints:
     - POST /api/v1/customers: create customer, returns 201 with Location header and CustomerResponse.
     - GET /api/v1/customers/{id}: fetch by id.
     - GET /api/v1/customers: paginated list (Page<CustomerResponse> or a wrapper with content + metadata).
     - PUT /api/v1/customers/{id}: full update.
     - PATCH /api/v1/customers/{id}: optional partial update (implement if needed); otherwise skip.
     - DELETE /api/v1/customers/{id}: delete, return 204.
   - Apply @Valid on request bodies. Use ResponseEntity and appropriate status codes. Reuse global exception handling for 404/validation errors.

8. OpenAPI specification updates.
   - Under openapi-starter/openapi/paths, add a new file paths/customers.yaml describing the above endpoints (GET list, GET by id, POST, PUT, DELETE). Reference schemas under components.
   - Under components/schemas, add CustomerRequest.yaml, CustomerUpdateRequest.yaml, CustomerResponse.yaml, and optionally CustomerPage.yaml or reuse a generic Page schema if present.
   - Wire paths in openapi-starter/openapi/openapi.yaml: add /api/v1/customers and /api/v1/customers/{id} entries referencing the new path file(s). Reuse Problem response and common headers as in existing spec. Keep naming conventions consistent (e.g., customers.yaml, customers_{id}.yaml if split).
   - Run redocly lint locally and fix any schema or reference issues. Take care even for the warnings from redocly lint.

9. Persistence mapping with BeerOrder.
   - Update BeerOrder entity to include a many-to-one relationship to Customer with @JoinColumn(name = "customer_id") if not already present.
   - Decide fetch strategies: LAZY for collections; ensure OSIV is disabled and fetch joins are used where required.

10. Validation and constraints.
   - Add Jakarta validation annotations on DTOs; enforce server-side constraints consistent with DB (NOT NULL, formats).
   - Consider custom validator for state or postal code formats if business rules exist; otherwise basic @Pattern.

11. Testing strategy and coverage.
   - Repository: @DataJpaTest slice tests: persist, find, constraints (e.g., required fields), relation to beer orders, and basic query/finder methods. Use Flyway to initialize schema.
   - Service: Mockk unit tests: mock repository and mapper, cover success and not found, duplicate email rule, transactional boundaries if observable.
   - Web: MockMvc slice tests: JSON serialization, validation errors, 201/200/204 statuses, pagination parameters, error handling via Problem Details.
   - If Testcontainers are used elsewhere, align with existing approach; otherwise rely on in-memory DB consistent with Flyway scripts.

12. Configuration updates.
   - Ensure spring.jpa.open-in-view=false (OSIV disabled) in application properties if not already set.
   - Enable auditing: @EnableJpaAuditing configuration class; set timezone/formatting preferences if needed.
   - Make sure Flyway is enabled (spring.flyway.enabled=true) and locations are default.

13. Gradle and tooling.
   - Verify build.gradle.kts includes dependencies: spring-boot-starter-data-jpa, flyway-core, mapstruct, mapstruct-processor (kapt/ksp), validation starter, jackson-module-kotlin. Configure annotation processing for MapStruct with Kotlin (kapt or ksp) and set Java/Kotlin target compatibility.
   - Add test dependencies for mockito-kotlin, spring-boot-starter-test, springmockk, and spring-security-test if needed.

14. Data migration and backward compatibility.
   - Ensure the new migration version follows existing sequencing and is idempotent. If BeerOrder already has data, set customer_id nullable initially or provide backfill strategy/defaults as needed.
   - Add foreign key constraints with ON DELETE RESTRICT (or SET NULL) based on business rule; adjust delete behavior in service (prevent delete when orders exist unless cascade is desired).

15. Logging, exceptions, and observability.
   - Use SLF4J for logging in service/controller; avoid sensitive data. Reuse or extend GlobalExceptionHandler to map NotFoundException and validation errors to ProblemDetails.
   - Add actuator exposure if any metrics/timers are added for customer operations.

16. Documentation and examples.
   - Update README or API docs references if needed. Provide sample payloads in OpenAPI components/examples.

17. Post-implementation verification.
   - Run unit and integration tests locally. Verify OpenAPI docs via redocly preview and the appâ€™s Swagger/Docs if present.
